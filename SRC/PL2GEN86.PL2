#
# MIT License
#
# Copyright (c) 2020 Viacheslav Komenda
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#

const I86_MOV_AX = "\xb8.."
const I86_CALL   = "\xe8.."
const I86_JMP    = "\xe9.."

function gen_word_size
        return 2
end

sub gen_op(op)
        if op = '+' then
                putbin(2, "\x01\xd8")
        elseif op = '-' then
                putbin(2, "\x29\xd8")
        elseif op = '*' then
                putbin(2, "\xf7\xeb")
        elseif op = '/' then
                putbin(4, "\x31\xd2\xf7\xf3")
        elseif op = '=' then
                putbin(9, "\x31\xC9\x39\xD8\x75\x01\x41\x89\xC8")
        elseif op = LEX_NE then
                putbin(9, "\x31\xC9\x39\xD8\x74\x01\x41\x89\xC8")
        elseif op = '<' then
                putbin(9, "\x31\xC9\x39\xD8\x73\x01\x41\x89\xC8")
        elseif op = LEX_LE then
                putbin(9, "\x31\xC9\x39\xD8\x7F\x01\x41\x89\xC8")
        elseif op = '>' then
                putbin(9, "\x31\xC9\x39\xD8\x7E\x01\x41\x89\xC8")
        elseif op = LEX_GE then
                putbin(9, "\x31\xC9\x39\xD8\x7C\x01\x41\x89\xC8")
        elseif op = LEX_OR then
                putbin(2, "\x09\xD8")
        elseif op = LEX_AND then
                putbin(2, "\x21\xD8")
        end
end

sub gen_call(ofs)
        putbin(3, I86_CALL)
        code%[code_ptr - 2] = ofs - code_ptr
end

sub gen_neg
        putbin(2, "\xF7\xD8")
end

sub gen_not
        putbin(11, "\x85\xC0\x75\x05\xB8\x01\x00\xEB\x02\x31\xC0")
end

sub gen_ret(pcount)
        putbin(3, "\x89\xec\x5d")
        if pcount then
                putbin(3, "\xc2..")
                code%[code_ptr - 2] = shl(pcount, 1)
        else
                putbin(1, "\xc3")
        end
end

sub gen_load_int(dig)
        if dig then
                putbin(3, I86_MOV_AX)
                code%[code_ptr - 2] = dig
        else
                putbin(2, "\x31\xC0")
        end
end

sub gen_exe_header
        dim bss_par, block_count, inlastblock, i

        memfill(code + code_ofs - 32, 32, 0)
        bss_par = &hffff - code_ptr + code_ofs
        if bin_and(bss_par, &h000F) then
                bss_par = shr(bss_par, 4) + 1
        else
                bss_par = shr(bss_par, 4)
        end
        inlastblock = mod(code_ptr - code_ofs, 512)
        block_count = (code_ptr - code_ofs) / 512
        if inlastblock then
                block_count = block_count + 1
        end

        i = code_ofs - 32
        code%[i] = &h5a4d
        code%[i+ 2] = inlastblock
        code%[i + 4] = block_count
        code%[i + 8] = 2
        code%[i + 10] = bss_par
        code%[i + 12] = bss_par
        code%[i + 14] = -&h10
        code%[i + 16] = &hfffe
        code%[i + 20] = code_ofs
        code%[i + 22] = -&h10
        code_ofs = i
        code_ptr = code_ptr + 32
end
