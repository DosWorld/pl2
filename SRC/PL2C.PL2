#
# MIT License
#
# Copyright (c) 2020 Viacheslav Komenda
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
include "pl2.pl2"
include "bdos.pl2"

const SYM_CONST  = 'C'
const SYM_FN     = 'F'
const SYM_SUB    = 'S'
const SYM_INLINE = 'I'
const SYM_INIT   = '!'
const SYM_DONE   = '?'
const SYM_LOCAL  = 'L'
const SYM_PARAM  = 'P'
const SYM_GLOBAL = 'G'
const SYM_KWD    = 'K'

const KWD_INCLUDE   = 1
const KWD_SUB       = 2
const KWD_FUNCTION  = 3
const KWD_DIM       = 4
const KWD_INIT      = 5
const KWD_FINAL     = 6
const KWD_END       = 7
const KWD_IF        = 8
const KWD_ELSEIF    = 9
const KWD_ELSE      = 10
const KWD_WHILE     = 11
const KWD_BREAK     = 12
const KWD_CONTINUE  = 13
const KWD_RETURN    = 14
const KWD_AT        = 15
const KWD_INLINE    = 16
const KWD_TRUE      = 17
const KWD_FALSE     = 18
const KWD_NOT       = 19

const LEX_EOF       = 1
const LEX_EOL       = 2
const LEX_DIGIT     = 3
const LEX_STR       = 4
const LEX_CHAR      = 5
const LEX_KWD       = 6
const LEX_ID        = 7
const LEX_OP        = 8

const DICT_TYP = 2
const DICT_PAR = 3
const DICT_OFS = 4
const DICT_HCD = 6
const DICT_NAM = 8

const I86_MOV_AX = "\xb8.."
const I86_CALL   = "\xe8.."
const I86_JMP    = "\xe9.."

const LBRAKET = "(",  RBRAKET = ")",  COMA = ","

dim code, code_ptr, code_ofs
dim line, line_ofs
dim lex, lex_size
dim table, table_ptr, dict_ptr

dim f, buf, buf_ptr, buf_size, eof, eol
dim lnum, csub, cdim
dim wh_break, wh_continue
dim cur_lex, cur_lex_type, cur_lex_ptr
dim out_file, map_file, out_lines
dim lib_dir, have_lib_dir
dim debug

dim stk_ret

sub error
        printi(lnum)
        print(":ERROR ")
        print(lex)
        print(" - ???")
        println()
        print(line)
        println()
        halt(1)
end

function putb(arr, ofs, b)
        poke(arr + ofs, b)
        return ofs + 1
end

function putw(arr, ofs, w)
        pokei(arr + ofs, w)
        return ofs + 2
end

sub putbin(count, str)
        memcopy(code + code_ptr, str, count)
        code_ptr = code_ptr + count
end

function is_iddig(c)
        return is_id(c) or is_digit(c)
end

sub change_ext(dst, src, new_ext)
        dim n, k
        n = 0
        while peek(src+n)
                n = n + 1
        end
        k = n
        while n <> 0
                if peek(src+n) = '.' then
                        break
                end
                n = n - 1
        end
        if (n = 0) and (peek(src) <> '.') then
                n = k
        end
        memcopy(dst, src, n)
        strcpy(dst + n, new_ext)
end

sub basename(dst, src)
        dim n
        n = 0
        while peek(src+n)
                n = n + 1
        end
        while n >= 0
                if peek(src+n) = '\\' then
                        break
                end
                if peek(src+n) = '/' then
                        break
                end
                n = n - 1
        end
        n = n + 1
        strcpy(dst, src + n)
end

function getchar
        dim cc
        if buf_ptr >= buf_size then
                if fread(f, buf) = 0 then
                        return 27
                end
                buf_ptr = 0
        end
        cc = buf[buf_ptr]
        buf_ptr = buf_ptr + 1
        return cc
end

function unhex(c)
        if is_digit(c) then
                return c - '0'
        end
        if (c >= 'A') and (c <= 'F') then
                return c - 'A' + 10
        end
        return FALSE
end

sub unesc
        dim i, k, c, c1, c2, esc

        i = 0
        k = 1
        while TRUE
                if lex[k] = '"' then
                        break
                end
                c = lex[k]
                k = k + 1
                if c = '\\' then
                        c = lex[k]
                        k = k + 1
                        if c = 'x' then
                                c1 = ucase(lex[k])
                                k = k + 1
                                c2 = ucase(lex[k])
                                k = k + 1
                                i = putb(lex, i, shl(unhex(c1), 4) or unhex(c2))
                        elseif c = '0' then
                                i = putb(lex, i, 0)
                        elseif c = 't' then
                                i = putb(lex, i, 9)
                        elseif c = 'n' then
                                i = putb(lex, i, 13)
                                i = putb(lex, i, 10)
                        else
                                i = putb(lex, i, c)
                        end
                else
                        i = putb(lex, i, c)
                end
        end
        lex_size = i
        lex[i] = 0
end

sub nextline
        dim i, c

        eol = FALSE
        line[0] = 0
        line_ofs = 0
        i = 0
        while not eof
                c = getchar()
                if c > ' ' then
                        break
                end
                if c = 27 then
                        eof = TRUE
                        break
                end
                if c = 10 then
                        eol = TRUE
                        break
                end
        end
        if eof then
                return
        end
        lnum = lnum + 1
        if eol then
                return
        end
        while TRUE
                if c = 13 then
                        c = getchar()
                        continue
                end
                if c = 10 then
                        break
                end
                if c = 27 then
                        break
                end
                i = putb(line, i, c)
                c = getchar()
        end
        line[i] = 0
        if debug then
                print("NEXLINE:[")
                print(line)
                print("]\n")
        end
end

sub def(name, type, p, ofs)
        dim k, c, hcode

        c = PEEK(name)
        if not (is_id(c) or (c = 0))  then
                error()
        end
        if debug then
                printhw(ofs)
                printc(' ')
                printc(type)
                printc(' ')
                print(name)
                println()
        end
        hcode = strhash(name)
        k = putw(table, table_ptr, dict_ptr)
        dict_ptr = table_ptr
        table_ptr = putb(table, k, type)
        table_ptr = putb(table, table_ptr, p)
        table_ptr = putw(table, table_ptr, ofs)
        table_ptr = putw(table, table_ptr, hcode)

        while c
                if not is_iddig(c) then
                        error()
                end
                table_ptr = putb(table, table_ptr, c)
                name = name + 1
                c = PEEK(name)
        end
        table_ptr = putb(table, table_ptr, 0)
end

function lookup(name)
        dim dptr,hcode

        hcode = strhash(name)
        dptr = dict_ptr
        while dptr <> -1
                if table%[dptr + DICT_HCD] = hcode then
                        if strcmp(name, table + dptr + DICT_NAM) = 0 then
                                break
                        end
                end
                dptr = table%[dptr]
        end
        return dptr
end

sub nextlex
        dim i, c

        cur_lex_type = 0
        lex_size = 0
        lex[0] = 0
        if eol then
                cur_lex_type = LEX_EOL
                return
        end
        i = line_ofs
        c = line[i]
        while c <= ' '
                if c = 0 then
                        eol = TRUE
                        cur_lex_type = LEX_EOL
                        break
                end
                i = i + 1
                c = line[i]
        end
        if is_id(c) then
                cur_lex_type = LEX_ID
                while is_iddig(c) <> 0
                        lex_size = putb(lex, lex_size, ucase(c))
                        i = i + 1
                        c = line[i]
                end
        elseif is_digit(c) then
                cur_lex_type = LEX_DIGIT
                while is_digit(c) <> 0
                        lex_size = putb(lex, lex_size, c)
                        i = i + 1
                        c = line[i]
                end
        elseif c = '"' then
                cur_lex_type = LEX_STR
                lex_size = putb(lex, lex_size, c)
                i = i + 1
                c = line[i]
                while c <> '"'
                        if c = 0 then
                                error()
                        end
                        lex_size = putb(lex, lex_size, c)
                        if c = '\\' then
                                i = i + 1
                                c = line[i]
                                lex_size = putb(lex, lex_size, c)
                                if c = 0 then
                                        error()
                                end
                        end
                        i = i + 1
                        c = line[i]
                end
                lex_size = putb(lex, lex_size, c)
                i = i + 1
        elseif c = '\'' then
                cur_lex_type = LEX_CHAR
                lex_size = putb(lex, lex_size, c)
                i = i + 1
                c = line[i]
                if c = '\\' then
                        i = i + 1
                        c = line[i]
                end
                lex_size = putb(lex, lex_size, c)
                i = i + 1
                c = line[i]
                if c <> '\'' then
                        error()
                end
                i = i + 1
        elseif c = '#' then
                c = 0
                eol = TRUE
        elseif c = '`' then
                c = 0
                eol = TRUE
        elseif c then
                cur_lex_type = LEX_OP
                lex_size = putb(lex, lex_size, c)
                i = i + 1
                if c = '<' then
                        if line[i] = '=' then
                                lex_size = putb(lex, lex_size, '=')
                                i = i + 1
                        elseif line[i] = '>' then
                                lex_size = putb(lex, lex_size, '>')
                                i = i + 1
                        end
                elseif c = '>' then
                        if line[i] = '=' then
                                lex_size = putb(lex, lex_size, '=')
                                i = i + 1
                        end
                end
        end
        lex[lex_size] = 0
        line_ofs = i
        cur_lex_ptr = -1
        if cur_lex_type = LEX_ID then
                cur_lex_ptr = lookup(lex)
                if cur_lex_ptr <> -1 then
                        cur_lex_type = table[cur_lex_ptr + DICT_TYP]
                end
        end

        if debug then
                print("NEXTLEX: [")
                if eol then
                        print("EOL")
                else
                        print(lex)
                end
                print("]\n")
        end
end

function accept(w)
        if strcmp(lex, w) = 0 then
                nextlex()
                return TRUE
        end
        return FALSE
end

function accept2(w1, w2)
        if strcmp(lex, w1) = 0 then
                nextlex()
                return TRUE
        elseif strcmp(lex, w2) = 0 then
                nextlex()
                return TRUE
        end
        return FALSE
end

sub expect(w)
        if not accept(w) then
                error()
        end
end

sub expect2(w1, w2)
        if not accept2(w1, w2) then
                error()
        end
end

sub expect_eol
        if not eol then
                error()
        end
end

sub pg_start
        putbin(3, I86_JMP)
        putbin(3, I86_JMP)
        def("RCODE", SYM_GLOBAL, 0, code_ptr)
        putbin(2, "\x00\x00")
        def("PLATFORM", SYM_GLOBAL, 0, code_ptr)
        putbin(2, "\x56\x00")
        def("FREE_MEMORY", SYM_GLOBAL, 0, code_ptr)
        putbin(2, "\x00\x00")

        def("INCLUDE", SYM_KWD, 0, KWD_INCLUDE)
        def("SUB", SYM_KWD, 0, KWD_SUB)
        def("FUNCTION", SYM_KWD, 0, KWD_FUNCTION)
        def("DIM", SYM_KWD, 0, KWD_DIM)
        def("INITIALIZATION", SYM_KWD, 0, KWD_INIT)
        def("FINALIZATION", SYM_KWD, 0, KWD_FINAL)
        def("END", SYM_KWD, 0, KWD_END)
        def("IF", SYM_KWD, 0, KWD_IF)
        def("ELSEIF", SYM_KWD, 0, KWD_ELSEIF)
        def("ELSE", SYM_KWD, 0, KWD_ELSE)
        def("WHILE", SYM_KWD, 0, KWD_WHILE)
        def("BREAK", SYM_KWD, 0, KWD_BREAK)
        def("CONTINUE", SYM_KWD, 0, KWD_CONTINUE)
        def("RETURN", SYM_KWD, 0, KWD_RETURN)
        def("AT", SYM_KWD, 0, KWD_AT)
        def("INLINE", SYM_KWD, 0, KWD_INLINE)
        def("TRUE", SYM_KWD, 0, KWD_TRUE)
        def("FALSE", SYM_KWD, 0, KWD_FALSE)
        def("NOT", SYM_KWD, 0, KWD_NOT)
end

sub gen_init(i, t)
        while i <> -1
                if table[i + DICT_TYP] = t then
                        if t = SYM_INIT then
                                gen_init(table%[i], t)
                                putbin(3, I86_CALL)
                                code%[code_ptr - 2] = table%[i + DICT_OFS] - code_ptr
                                return
                        elseif t = SYM_DONE then
                                putbin(3, I86_CALL)
                                code%[code_ptr - 2] = table%[i + DICT_OFS] - code_ptr
                        end
                end
                i = table%[i]
        end
end

sub pg_end
        dim i

        # fix jump to main part
        code%[code_ofs + 1] = code_ptr - 3 - code_ofs

        # Call INITIALIZATION's
        gen_init(dict_ptr, SYM_INIT)

        # Call Main
        i = lookup("MAIN")
        if i = -1 then
                print("No main() sub here.\n")
                error()
        end
        putbin(3, I86_CALL)
        code%[code_ptr - 2] = table%[i + DICT_OFS] - code_ptr

        # fix jmp for halt (on halt will jmp here)
        code%[code_ofs + 6 - 2] = code_ptr - code_ofs - 6

        # Gen call all FINALIZATION's
        gen_init(dict_ptr, SYM_DONE)
        putbin(1, "\xA0")
        code_ptr = putw(code, code_ptr, code_ofs + 6)
        putbin(4, "\xB4\x4C\xCD\x21")

        # Now, we know where program ends
        i = lookup("FREE_MEMORY")
        code%[table%[i + DICT_OFS]] = code_ptr
        print("Save ")
        print(out_file)
        printc(' ')
        printi(out_lines)
        print(" lines, ")
        printi(code_ptr - code_ofs)
        print(" bytes\n")
        bsave(out_file, code + code_ofs, code_ptr - code_ofs)
        table_ptr = putw(table, table_ptr, dict_ptr)
        bsave(map_file, table, table_ptr)
end

function parse_digit
        dim ofs, i
        ofs = 0
        i = 0
        while is_digit(lex[ofs])
                i = i * 10
                i = i + lex[ofs] - '0'
                ofs = ofs + 1
        end
        return i
end

sub expr(lvl)
        dim ofs, i, op, p2, t, var, is_neg, is_not, k

        is_neg = FALSE
        is_not = FALSE
        if accept("-") then
                is_neg = TRUE
        end
        if accept("NOT") then
                is_not = TRUE
        end
        if accept(LBRAKET) then
                expr(lvl)
                expect(RBRAKET)
        elseif accept("TRUE") then
                putbin(3, I86_MOV_AX)
                code%[code_ptr - 2] = 1
        elseif accept("FALSE") then
                putbin(2, "\x31\xC0")
        elseif cur_lex_type = LEX_CHAR then
                putbin(3, I86_MOV_AX)
                code%[code_ptr - 2] = lex[1]
                nextlex()
        elseif cur_lex_type = LEX_STR then
                unesc()
                putbin(3, I86_CALL)
                ofs = code_ptr
                putbin(lex_size, lex)
                putbin(1, "\x00")
                code%[ofs - 2] = code_ptr - ofs
                putbin(1, "\x58")
                nextlex()
        elseif cur_lex_type = LEX_DIGIT then
                i = parse_digit()
                if is_neg then
                        i = -i
                        is_neg = FALSE
                end
                if i then
                        putbin(3, I86_MOV_AX)
                        code%[code_ptr - 2] = i
                else
                        putbin(2, "\x31\xC0")
                end
                nextlex()
        else
                var = cur_lex_ptr
                if var = -1 then
                        error()
                end
                nextlex()
                t = table[var + DICT_TYP]
                if t = SYM_GLOBAL then
                        i = code_ptr
                        putbin(3, "\xa1..")
                        code%[code_ptr - 2] = table%[var + DICT_OFS]
                        if accept(LBRAKET) then
                                code_ptr = i
                                while strcmp(lex, RBRAKET)
                                        expr(0)
                                        putbin(1, "\x50")
                                        if not accept(COMA) then
                                                break
                                        end
                                end
                                expect(RBRAKET)
                                putbin(4, "\xFF\x16..")
                                code%[code_ptr - 2] = table%[var + DICT_OFS]
                        elseif accept("[") then
                                putbin(1, "\x50")
                                expr(0)
                                putbin(7, "\x5B\x01\xC3\x8A\x07\xb4\x00")
                                expect("]")
                        elseif accept("%") then
                                expect("[")
                                putbin(1, "\x50")
                                expr(0)
                                putbin(5, "\x5B\x01\xC3\x8B\x07")
                                expect("]")
                        end
                elseif t = SYM_PARAM then
                        t = 2 + table[csub + DICT_PAR] - table[var + DICT_PAR]
                        putbin(3, "\x8b\x46\.")
                        code[code_ptr - 1] = shl(t, 1)
                elseif t = SYM_LOCAL then
                        t = shl(1 + table[var + DICT_PAR], 1)
                        putbin(3, "\x8b\x46.")
                        code[code_ptr - 1] = -t
                elseif t = SYM_FN then
                        if accept(LBRAKET) then
                                while strcmp(lex, RBRAKET)
                                        expr(0)
                                        putbin(1, "\x50")
                                        if not accept(COMA) then
                                                break
                                        end
                                end
                                expect(RBRAKET)
                                putbin(3, I86_CALL)
                                code%[code_ptr - 2] = table%[var + DICT_OFS] - code_ptr
                        else
                                putbin(3, I86_MOV_AX)
                                code%[code_ptr - 2] = table%[var + DICT_OFS]
                        end
                elseif t = SYM_CONST then
                        i = table%[var + DICT_OFS]
                        if i then
                                putbin(3, I86_MOV_AX)
                                code%[code_ptr - 2] = i
                        else
                                putbin(2, "\x31\xC0")
                        end
                elseif t = SYM_INLINE then
                        if accept(LBRAKET) then
                                while strcmp(lex, RBRAKET) <> 0
                                        expr(0)
                                        putbin(1, "\x50")
                                        if not accept(COMA) then
                                                break
                                        end
                                end
                                expect(RBRAKET)
                        end
                        putbin(table[var + DICT_PAR], table + table%[var + DICT_OFS])
                else
                        error()
                end
        end

        if is_neg then
                putbin(2, "\xF7\xD8")
        end
        if is_not then
                putbin(11, "\x85\xC0\x75\x05\xB8\x01\x00\xEB\x02\x31\xC0")
        end

        while not eol
                if strcmp(lex, "=") = 0 then
                        op = '='
                        p2 = 3
                elseif strcmp(lex, "<>") = 0 then
                        op = 'N'
                        p2 = 3
                elseif strcmp(lex, "<") = 0 then
                        op = '<'
                        p2 = 4
                elseif strcmp(lex, "<=") = 0 then
                        op = 'L'
                        p2 = 4
                elseif strcmp(lex, ">") = 0 then
                        op = '>'
                        p2 = 4
                elseif strcmp(lex, ">=") = 0 then
                        op = 'G'
                        p2 = 4
                elseif strcmp(lex, "OR") = 0 then
                        op = '|'
                        p2 = 1
                elseif strcmp(lex, "AND") = 0 then
                        op = '&'
                        p2 = 2
                elseif strcmp(lex, "+") = 0 then
                        op = '+'
                        p2 = 5
                elseif strcmp(lex, "-") = 0 then
                        op = '-'
                        p2 = 5
                elseif strcmp(lex, "*") = 0 then
                        op = '*'
                        p2 = 6
                elseif strcmp(lex, "/") = 0 then
                        op = '/'
                        p2 = 6
                else
                        return
                end
                if p2 <= lvl then
                        return
                end
                nextlex()
                putbin(1, "\x50")
                expr(p2)
                putbin(3, "\x89\xc3\x58")
                if op = '+' then
                        putbin(2, "\x01\xd8")
                elseif op = '-' then
                        putbin(2, "\x29\xd8")
                elseif op = '*' then
                        putbin(2, "\xf7\xeb")
                elseif op = '/' then
                        putbin(2, "\x31\xd2\xf7\xf3")
                elseif op = '=' then
                        putbin(9, "\x31\xC9\x39\xD8\x75\x01\x41\x89\xC8")
                elseif op = 'N' then
                        putbin(9, "\x31\xC9\x39\xD8\x74\x01\x41\x89\xC8")
                elseif op = '<' then
                        putbin(9, "\x31\xC9\x39\xD8\x73\x01\x41\x89\xC8")
                elseif op = 'L' then
                        putbin(9, "\x31\xC9\x39\xD8\x7F\x01\x41\x89\xC8")
                elseif op = '>' then
                        putbin(9, "\x31\xC9\x39\xD8\x7E\x01\x41\x89\xC8")
                elseif op = 'G' then
                        putbin(9, "\x31\xC9\x39\xD8\x7C\x01\x41\x89\xC8")
                elseif op = '|' then
                        putbin(2, "\x09\xD8")
                elseif op = '&' then
                        putbin(2, "\x21\xD8")
                end
        end
end

sub statements
        dim old_wh_continue, old_wh_break, k, i, else_jmp, exit_jmp, have_else

        while not eof
                nextlex()
                if eol then
                        nextline()
                        continue
                end
                i = cur_lex_ptr
                if i = -1 then
                        error()
                end

                k = table[i + DICT_TYP]
                if k = SYM_KWD then
                        k = table[i + DICT_OFS]
                        if k = KWD_END then
                                return
                        end
                        if k = KWD_ELSEIF then
                                return
                        end
                        if k = KWD_ELSE then
                                return
                        end
                        nextlex()
                        if k = KWD_IF then
                                have_else = FALSE
                                expr(0)
                                expect("THEN")
                                nextline()
                                putbin(7, "\x85\xc0\x75\x03\xe9..")
                                else_jmp = code_ptr
                                statements()
                                while accept("ELSEIF")
                                        if have_else then
                                                code%[exit_jmp - 2] = code_ptr - exit_jmp
                                        end
                                        putbin(3, I86_JMP)
                                        exit_jmp = code_ptr
                                        have_else = TRUE
                                        code%[else_jmp - 2] = code_ptr - else_jmp
        
                                        expr(0)
                                        putbin(7, "\x85\xc0\x75\x03\xe9..")
                                        else_jmp = code_ptr
                                        expect("THEN")
                                        expect_eol()
                                        nextline()
                                        statements()
                                end
                                if accept("ELSE") then
                                        if have_else then
                                                code%[exit_jmp - 2] = code_ptr - exit_jmp
                                        end
                                        putbin(3, I86_JMP)
                                        exit_jmp = code_ptr
                                        have_else = TRUE
                                        code%[else_jmp - 2] = code_ptr - else_jmp
                                        expect_eol()
                                        nextline()
                                        statements()
                                else
                                        code%[else_jmp - 2] = code_ptr - else_jmp
                                end
                                if have_else then
                                        code%[exit_jmp - 2] = code_ptr - exit_jmp
                                end
                                expect("END")
                        elseif k = KWD_WHILE then
                                old_wh_continue = wh_continue
                                old_wh_break = wh_break
                                wh_continue = code_ptr
                                expr(0)
                                putbin(7, "\x85\xc0\x75\x03\xe9..")
                                wh_break = code_ptr - 3
                                expect_eol()
                                nextline()
                                statements()
                                expect("END")
                                putbin(3, I86_JMP)
                                code%[code_ptr - 2] = wh_continue - code_ptr
                                wh_break = wh_break + 3
                                code%[wh_break - 2] = code_ptr - wh_break
                                wh_continue = old_wh_continue
                                wh_break = old_wh_break
                        elseif k = KWD_CONTINUE then
                                putbin(3, I86_JMP)
                                code%[code_ptr - 2] = wh_continue - code_ptr
                        elseif k = KWD_BREAK then
                                putbin(3, I86_JMP)
                                code%[code_ptr - 2] = wh_break - code_ptr
                        elseif k = KWD_RETURN then
                                if not eol then
                                        expr(0)
                                end
                                putbin(3, I86_JMP)
                                stk_ret%[0] = stk_ret%[0] + 2
                                stk_ret%[stk_ret%[0]] = code_ptr
                        elseif k = KWD_DIM then
                                while not eol
                                        def(lex, SYM_LOCAL, cdim, cdim)
                                        cdim = cdim + 1
                                        nextlex()
                                        if not accept(COMA) then
                                                expect_eol()
                                        end
                                end
                        elseif k = KWD_INLINE then
                                expect(LBRAKET)
                                if lex[0] <> '"' then
                                        error()
                                end
                                unesc()
                                putbin(lex_size, lex)
                                nextlex()
                                expect(RBRAKET)
                        end
                elseif (k = SYM_FN) or (k = SYM_SUB) then
                        nextlex()
                        if accept(LBRAKET) then
                                while strcmp(lex, RBRAKET) <> 0
                                        expr(0)
                                        putbin(1, "\x50")
                                        if not accept(COMA) then
                                                break
                                        end
                                end
                                expect(RBRAKET)
                        end
                        putbin(3, I86_CALL)
                        code%[code_ptr - 2] = table%[i + DICT_OFS] - code_ptr
                elseif k = SYM_INLINE then
                        nextlex()
                        if accept(LBRAKET) then
                                while strcmp(lex, RBRAKET) <> 0
                                        expr(0)
                                        putbin(1, "\x50")
                                        if not accept(COMA) then
                                                break
                                        end
                                end
                                expect(RBRAKET)
                        end
                        putbin(table[i + DICT_PAR], table + table%[i + DICT_OFS])
                elseif k = SYM_PARAM then
                        nextlex()
                        k = shl(2 + table[csub + DICT_PAR] - table[i + DICT_PAR], 1)
                        if accept("=") then
                                expr(0)
                                putbin(3, "\x89\x46.")
                                code[code_ptr - 1] = k
                        elseif accept(LBRAKET) then
                                while strcmp(lex, RBRAKET) <> 0
                                        expr(0)
                                        putbin(1, "\x50")
                                        if not accept(COMA) then
                                                break
                                        end
                                end
                                expect(RBRAKET)
                                putbin(3, "\xFF\x56.")
                                code[code_ptr - 1] = k
                        else
                                error()
                        end
                elseif k = SYM_LOCAL then
                        nextlex()
                        k = -shl(1 + table[i + DICT_PAR], 1)
                        if accept("=") then
                                expr(0)
                                putbin(3, "\x89\x46.")
                                code[code_ptr - 1] = k
                        elseif accept(LBRAKET) then
                                while strcmp(lex, RBRAKET) <> 0
                                        expr(0)
                                        putbin(1, "\x50")
                                        if not accept(COMA) then
                                                break
                                        end
                                end
                                expect(RBRAKET)
                                putbin(3, "\xFF\x56.")
                                code[code_ptr - 1] = k
                        else
                                error()
                        end
                elseif k = SYM_GLOBAL then
                        nextlex()
                        k = table%[i + DICT_OFS]
                        if accept("=") then
                                expr(0)
                                putbin(3, "\xA3..")
                                code%[code_ptr - 2] = k
                        elseif accept(LBRAKET) then
                                while strcmp(lex, RBRAKET) <> 0
                                        expr(0)
                                        putbin(1, "\x50")
                                        if not accept(COMA) then
                                                break
                                        end
                                end
                                expect(RBRAKET)
                                putbin(4, "\xFF\x16..")
                                code%[code_ptr - 2] = k
                        elseif accept("[") then
                                expr(0)
                                expect("]")
                                putbin(1, "\x50")
                                expect("=")
                                expr(0)
                                putbin(7, "\x5b\x03\x1E..\x88\x07")
                                code%[code_ptr - 4] = k
                        elseif accept("%") then
                                expect("[")
                                expr(0)
                                expect("]")
                                putbin(1, "\x50")
                                expect("=")
                                expr(0)
                                putbin(7, "\x5b\x03\x1E..\x89\x07")
                                code%[code_ptr - 4] = k
                        else
                                error()
                        end

                end
                expect_eol()
                nextline()
        end
end

sub c_fixrets
        dim stk_ret_ptr, p

        stk_ret_ptr = stk_ret%[0]

        while (stk_ret_ptr <> 0) and (stk_ret%[stk_ret_ptr] = code_ptr)
                code_ptr = code_ptr - 3
                stk_ret_ptr = stk_ret_ptr - 2
        end
        while stk_ret_ptr <> 0
                p = stk_ret%[stk_ret_ptr]
                code%[p - 2] = code_ptr - p
                stk_ret_ptr = stk_ret_ptr - 2
        end
        stk_ret%[stk_ret_ptr] = 0
end

sub c_sub(type)
        dim save_dict_ptr, save_table_ptr, pcount
        dim save_buf_ptr, loc_ptr, i

        stk_ret%[0] = 0
        def(lex, type, 0, code_ptr)
        csub = dict_ptr
        cdim = 0
        save_dict_ptr = dict_ptr
        save_table_ptr = table_ptr
        pcount = 0
        putbin(3, "\x55\x89\xe5")
        putbin(3, "\x83\xec.")
        loc_ptr = code_ptr
        nextlex()
        if accept(LBRAKET) then
                while TRUE
                        pcount = pcount + 1
                        def(lex, SYM_PARAM, pcount, pcount)
                        nextlex()
                        if accept(RBRAKET) then
                                break
                        end
                        expect(COMA)
                end
        end
        expect_eol()
        nextline()
        table[save_dict_ptr + DICT_PAR] = pcount
        statements()
        expect("END")
        code[loc_ptr - 1] = shl(cdim, 1)
        c_fixrets()
        putbin(3, "\x89\xec\x5d")
        if pcount then
                putbin(3, "\xc2..")
                code%[code_ptr - 2] = shl(pcount, 1)
        else
                putbin(1, "\xc3")
        end
        dict_ptr = save_dict_ptr
        table_ptr = save_table_ptr
end

sub c_dim
        dim bytes
        while not eol
                def(lex, SYM_GLOBAL, 0, code_ptr)
                nextlex()
                code_ptr = putw(code, code_ptr, 0)
                if not accept(COMA) then
                        expect_eol()
                end
        end
end

sub c_const
        dim bytes, t, val
        while not eol
                def(lex, SYM_CONST, 0, 0)
                nextlex()
                expect("=")
                if accept("FILE") then
                        expect(LBRAKET)
                        val = code_ptr
                        if lex[0] <> '"' then
                                error()
                        end
                        unesc()
                        bytes = bload(lex, code + code_ptr)
                        if bytes = 0 then
                                if have_lib_dir then
                                        strcpy(FREE_MEMORY, lib_dir)
                                        bytes = len(lib_dir)
                                        basename(FREE_MEMORY + bytes, lex)
                                        bytes = bload(FREE_MEMORY, code + code_ptr)
                                        if bytes = 0 then
                                                error()
                                        end
                                else
                                        error()
                                end
                        end
                        code_ptr = code_ptr + bytes
                        nextlex()
                        expect(RBRAKET)
                elseif lex[0] = '"' then
                        unesc()
                        val = code_ptr
                        putbin(lex_size, lex)
                        putbin(1, "\x00")
                        nextlex()
                elseif lex[0] = '\'' then
                        val = lex[1]
                        nextlex()
                else
                        val = parse_digit()
                        nextlex()
                end
                table%[dict_ptr + DICT_OFS] = val
                if not accept(COMA) then
                        expect_eol()
                end
        end
end

sub c_declare
        dim pcount, t

        expect2("SUB", "FUNCTION")
        def(lex, SYM_FN, 0, 0)
        nextlex()
        pcount = 0
        if accept(LBRAKET) then
                while not eol
                        pcount = pcount + 1
                        nextlex()
                        if not accept(COMA) then
                                break
                        end
                end
                expect(RBRAKET)
        end
        table[dict_ptr + DICT_PAR] = pcount
        if accept("AT") then
                t = lookup(lex)
                if t = -1 then
                        error()
                end
                if table[t + DICT_TYP] <> SYM_CONST then
                        error()
                end
                nextlex()
                expect("[")
                table%[dict_ptr + DICT_OFS] = table%[t + DICT_OFS] + parse_digit()
                nextlex()
                expect("]")
        elseif accept("INLINE") then
                expect(LBRAKET)
                if lex[0] <> '"' then
                        error()
                end
                unesc()
                if lex_size > 255 then
                        error()
                end
                table[dict_ptr + DICT_TYP] = SYM_INLINE
                table[dict_ptr + DICT_PAR] = lex_size
                table%[dict_ptr + DICT_OFS] = table_ptr
                t = 0
                while t < lex_size
                        table[table_ptr] = lex[t]
                        table_ptr = table_ptr + 1
                        t = t + 1
                end
                nextlex()
                expect(RBRAKET)
                expect_eol()
        else
                error()
        end
end

# Compile Initialization/finalization
sub c_inital_final(t)
        dim loc_ptr

        stk_ret%[0] = 0
        nextline()
        def("", t, 0, code_ptr)
        putbin(2, "\x89\xe5")
        putbin(3, "\x83\xec.")
        loc_ptr = code_ptr
        cdim = 0
        statements()
        expect("END")
        code[loc_ptr - 1] = shl(cdim + 1, 1)
        c_fixrets()
        putbin(3, "\x89\xec\xc3")
end

function compile(fname)
        dim save_f, save_buf_ptr, save_lnum
        dim total_lines

        total_lines = 0
        save_f = f
        save_buf_ptr = buf_ptr
        save_lnum = lnum
        f = fopenr(fname)
        if f = 0 then
                if have_lib_dir then
                        strcpy(FREE_MEMORY, lib_dir)
                        save_lnum = len(lib_dir)
                        basename(FREE_MEMORY + save_lnum, fname)
                        f = fopenr(FREE_MEMORY)
                        if f = 0 then
                                error()
                        end
                else
                        error()
                end
        end
        print(fname)
        println()
        buf_ptr  = buf_size + 1
        buf = buf + 128
        eof = FALSE
        eol = FALSE
        lnum = 0

        nextline()
        while not eof
                nextlex()
                if eol then
                        nextline()
                        continue
                end
                if accept("SUB") then
                        c_sub(SYM_SUB)
                elseif accept("FUNCTION") then
                        c_sub(SYM_FN)
                elseif accept("DIM") then
                        c_dim()
                elseif accept("DECLARE") then
                        c_declare()
                elseif accept("CONST") then
                        c_const()
                elseif accept("INITIALIZATION") then
                        c_inital_final(SYM_INIT)
                elseif accept("FINALIZATION") then
                        c_inital_final(SYM_DONE)
                elseif accept("INCLUDE") then
                        if lex[0] <> '"' then
                                error()
                        end
                        unesc()
                        total_lines = total_lines + compile(lex)
                        nextlex()
                else
                        error()
                end
                nextline()
        end

        fclose(f)
        buf = buf - 128
        f = save_f
        buf_ptr = save_buf_ptr
        total_lines = total_lines + lnum
        lnum = save_lnum
        eof = FALSE
        return total_lines
end

initialization
        debug = false

        lib_dir = FREE_MEMORY
        FREE_MEMORY = FREE_MEMORY + 256

        out_file = FREE_MEMORY
        FREE_MEMORY = FREE_MEMORY + 256

        map_file = FREE_MEMORY
        FREE_MEMORY = FREE_MEMORY + 256

        stk_ret = FREE_MEMORY
        FREE_MEMORY = FREE_MEMORY + 128

        lex = FREE_MEMORY
        FREE_MEMORY = FREE_MEMORY + 1024
        line = FREE_MEMORY
        FREE_MEMORY = FREE_MEMORY + 1024
        buf = FREE_MEMORY
        FREE_MEMORY = FREE_MEMORY + 2048
        table = FREE_MEMORY
        FREE_MEMORY = FREE_MEMORY + 6144
        code = table + 6144

        code_ptr = 256
        code_ofs = 256
        lex_size = 0
        buf_size = 128
        table_ptr = 0
        dict_ptr = -1
        code_ofs = 256
end

sub main
        dim in_file
        print("PL/2-86 Compiler  (c) 2020 DosWorld  MIT License\n")
        if paramcount() <> 1 then
                print("\nUsage:\n\tPL2C source.pl2\n")
                halt(1)
        end
        getenv("PL2_HOME", lib_dir)
        if len(lib_dir) = 0 then
                print("WARN:Env var PL2_HOME is not set.\n")
        else
                have_lib_dir = true
                dim n
                n = len(lib_dir)
                if (lib_dir[n] <> '\\') and (lib_dir[n] <> '/') then
                        lib_dir[n] = '\\'
                        n = n + 1
                        lib_dir[n] = 0
                end
                strcpy(lib_dir + n, "LIB\\")
        end
        in_file = paramstr(1)
        change_ext(out_file, in_file, ".com")
        change_ext(map_file, in_file, ".map")
        pg_start()
        out_lines = compile(in_file)
        pg_end()
        halt(0)
end
