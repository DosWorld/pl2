#
# MIT License
#
# Copyright (c) 2020 Viacheslav Komenda
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#

function getchar
        dim cc
        if buf_ptr >= buf_size then
                if fread(f, buf) = 0 then
                        return 27
                end
                buf_ptr = 0
        end
        cc = buf[buf_ptr]
        buf_ptr = buf_ptr + 1
        return cc
end

function unhex(c)
        if is_digit(c) then
                return c - '0'
        end
        if (c >= 'A') and (c <= 'F') then
                return c - 'A' + 10
        end
        return FALSE
end

sub unesc
        dim i, k, c, c1, c2, esc

        i = 0
        k = 1
        while TRUE
                if lex[k] = '"' then
                        break
                end
                c = lex[k]
                k = k + 1
                if c = '\\' then
                        c = lex[k]
                        k = k + 1
                        if c = 'x' then
                                c1 = ucase(lex[k])
                                k = k + 1
                                c2 = ucase(lex[k])
                                k = k + 1
                                i = putb(lex, i, shl(unhex(c1), 4) or unhex(c2))
                        elseif c = '0' then
                                i = putb(lex, i, 0)
                        elseif c = 't' then
                                i = putb(lex, i, 9)
                        elseif c = 'n' then
                                i = putb(lex, i, 13)
                                i = putb(lex, i, 10)
                        else
                                i = putb(lex, i, c)
                        end
                else
                        i = putb(lex, i, c)
                end
        end
        lex_size = i
        lex[i] = 0
end

sub nextline
        dim i, c

        eol = FALSE
        line[0] = 0
        line_ofs = 0
        i = 0
        while true
                c = getchar()
                if c > ' ' then
                        break
                end
                if c = 27 then
                        break
                end
                if c = 10 then
                        eol = TRUE
                        break
                end
        end
        lnum = lnum + 1
        if eol then
                return
        end
        while TRUE
                if c = 13 then
                        c = getchar()
                        continue
                end
                if c = 10 then
                        break
                end
                if c = 27 then
                        i = putb(line, i, c)
                        break
                end
                i = putb(line, i, c)
                c = getchar()
        end
        line[i] = 0
        if debug then
                print("NEXLINE:[")
                print(line)
                print("]\n")
        end
end

sub def(name, type, p, ofs)
        dim k, c, hcode

        c = PEEK(name)
        if not (is_id(c) or (c = 0))  then
                error()
        end
        if debug then
                printhw(ofs)
                printc(' ')
                printi(type)
                printc(' ')
                print(name)
                println()
        end
        hcode = strhash(name)
        k = putw(table, table_ptr, dict_ptr)
        dict_ptr = table_ptr
        table_ptr = putw(table, k, type)
        table_ptr = putw(table, table_ptr, p)
        table_ptr = putw(table, table_ptr, ofs)
        table_ptr = putw(table, table_ptr, hcode)

        while c
                if not is_iddig(c) then
                        error()
                end
                table_ptr = putb(table, table_ptr, c)
                name = name + 1
                c = PEEK(name)
        end
        table_ptr = putb(table, table_ptr, 0)
end

function lookup(name)
        dim dptr,hcode

        hcode = strhash(name)
        dptr = dict_ptr
        while dptr <> -1
                if table%[dptr + DICT_HCD] = hcode then
                        if strcmp(name, table + dptr + DICT_NAM) = 0 then
                                break
                        end
                end
                dptr = table%[dptr]
        end
        return dptr
end

sub nextlex
        dim i, c

        if cur_lex_type = LEX_EOF then
                if debug then
                        print("NEXTLEX: [EOF]\n")
                end
                return
        end

        cur_lex_type = 0
        lex_size = 0
        lex[0] = 0
        digit = 0

        if eol then
                cur_lex_type = LEX_EOL
                return
        end
        i = line_ofs
        c = line[i]
        while c <= ' '
                if c = 0 then
                        eol = TRUE
                        cur_lex_type = LEX_EOL
                        break
                end
                if c = 27 then
                        break
                end
                i = i + 1
                c = line[i]
        end
        if is_id(c) then
                cur_lex_type = LEX_ID
                while is_iddig(c) <> 0
                        lex_size = putb(lex, lex_size, ucase(c))
                        i = i + 1
                        c = line[i]
                end
        elseif is_digit(c) then
                cur_lex_type = LEX_DIGIT
                while is_digit(c) <> 0
                        digit = digit * 10
                        lex_size = putb(lex, lex_size, c)
                        digit = digit + c - '0'
                        i = i + 1
                        c = line[i]
                end
        elseif c = '"' then
                cur_lex_type = LEX_STR
                lex_size = putb(lex, lex_size, c)
                i = i + 1
                c = line[i]
                while c <> '"'
                        if c = 0 then
                                error()
                        end
                        lex_size = putb(lex, lex_size, c)
                        if c = '\\' then
                                i = i + 1
                                c = line[i]
                                lex_size = putb(lex, lex_size, c)
                                if c = 0 then
                                        error()
                                end
                        end
                        i = i + 1
                        c = line[i]
                end
                lex_size = putb(lex, lex_size, c)
                i = i + 1
        elseif c = '\'' then
                cur_lex_type = LEX_CHAR
                lex_size = putb(lex, lex_size, c)
                i = i + 1
                c = line[i]
                if c = '\\' then
                        i = i + 1
                        c = line[i]
                        if c = 't' then
                                c = 9
                        elseif c = 'n' then
                                c = 10
                        elseif c = 'r' then
                                c = 13
                        end
                end
                lex_size = putb(lex, lex_size, c)
                i = i + 1
                c = line[i]
                if c <> '\'' then
                        error()
                end
                i = i + 1
        elseif c = '#' then
                c = 0
                eol = TRUE
                cur_lex_type = LEX_EOL
        elseif c = '`' then
                c = 0
                eol = TRUE
                cur_lex_type = LEX_EOL
        elseif c = 27 then
                c = 0
                cur_lex_type = LEX_EOF
        elseif c then
                lex_size = putb(lex, lex_size, c)
                i = i + 1
                if c = '<' then
                        if line[i] = '=' then
                                lex_size = putb(lex, lex_size, '=')
                                i = i + 1
                                cur_lex_type = LEX_LE
                        elseif line[i] = '>' then
                                lex_size = putb(lex, lex_size, '>')
                                i = i + 1
                                cur_lex_type = LEX_NE
                        else
                                cur_lex_type = c
                        end
                elseif c = '>' then
                        if line[i] = '=' then
                                lex_size = putb(lex, lex_size, '=')
                                i = i + 1
                                cur_lex_type = LEX_GE
                        else
                                cur_lex_type = c
                        end
                else
                        cur_lex_type = c
                end
        end
        lex[lex_size] = 0
        line_ofs = i
        cur_lex_ptr = -1
        if cur_lex_type = LEX_ID then
                cur_lex_ptr = lookup(lex)
                if cur_lex_ptr <> -1 then
                        cur_lex_type = table%[cur_lex_ptr + DICT_TYP]
                end
        end

        if debug then
                print("NEXTLEX: ")
                printi(cur_lex_type)
                print(" [")
                if cur_lex_type = LEX_EOL then
                        print("EOL")
                elseif cur_lex_type = LEX_EOF then
                        print("EOF")
                else
                        print(lex)
                end
                print("]\n")
        end
end

function accept(w)
        if cur_lex_type = w then
                if w = LEX_EOL then
                        nextline()
                end
                nextlex()
                return TRUE
        end
        return FALSE
end

function accept2(w1, w2)
        if accept(w1) then
                return TRUE
        elseif accept(w2) then
                return TRUE
        end
        return FALSE
end

sub expect(w)
        if not accept(w) then
                error()
        end
end

sub expect2(w1, w2)
        if not accept2(w1, w2) then
                error()
        end
end

sub pg_start
        putbin(3, I86_JMP)
        putbin(3, I86_JMP)
        def("RCODE", SYM_GLOBAL, 0, code_ptr)
        code_ptr = putw(code, code_ptr, 0)
        def("PLATFORM", SYM_GLOBAL, 0, code_ptr)
        code_ptr = putw(code, code_ptr, 86)
        def("FREE_MEMORY", SYM_GLOBAL, 0, code_ptr)
        code_ptr = putw(code, code_ptr, 0)
end

sub gen_init(i, t)
        while i <> -1
                if table%[i + DICT_TYP] = t then
                        if t = SYM_INIT then
                                gen_init(table%[i], t)
                                gen_call(table%[i + DICT_OFS])
                                return
                        elseif t = SYM_DONE then
                                gen_call(table%[i + DICT_OFS])
                        end
                end
                i = table%[i]
        end
end

sub pg_end
        dim i

        # fix jump to main part
        code%[code_ofs + 1] = code_ptr - 3 - code_ofs

        # Call INITIALIZATION's
        gen_init(dict_ptr, SYM_INIT)

        # Call Main
        i = lookup("MAIN")
        if i = -1 then
                print("No main() sub here.\n")
                error()
        end
        gen_call(table%[i + DICT_OFS])

        # fix jmp for halt (on halt will jmp here)
        code%[code_ofs + 6 - 2] = code_ptr - code_ofs - 6

        # Gen call all FINALIZATION's
        gen_init(dict_ptr, SYM_DONE)
        putbin(1, "\xA0")
        code_ptr = putw(code, code_ptr, code_ofs + 6)
        putbin(4, "\xB4\x4C\xCD\x21")

        # Now, we know where program ends and where starts free memory
        i = lookup("FREE_MEMORY")
        code%[table%[i + DICT_OFS]] = code_ptr
end

function is_lex(t)
        return cur_lex_type = t
end

sub expr(lvl)
        dim ofs, i, op, p2, t, var, is_neg, is_not, k, dig

        is_neg = FALSE
        is_not = FALSE
        if accept('-') then
                is_neg = TRUE
        end
        if accept(LEX_NOT) then
                is_not = TRUE
        end
        var = cur_lex_ptr
        dig = digit
        if accept('(') then
                expr(lvl)
                expect(')')
        elseif accept(LEX_TRUE) then
                gen_load_int(1)
        elseif accept(LEX_FALSE) then
                gen_load_int(0)
        elseif cur_lex_type = LEX_CHAR then
                gen_load_int(lex[1])
                expect(LEX_CHAR)
        elseif cur_lex_type = LEX_STR then
                unesc()
                putbin(3, I86_CALL)
                ofs = code_ptr
                putbin(lex_size, lex)
                putbin(1, "\x00")
                code%[ofs - 2] = code_ptr - ofs
                putbin(1, "\x58")
                expect(LEX_STR)
        elseif accept(LEX_DIGIT) then
                if is_neg then
                        dig = -dig
                        is_neg = FALSE
                end
                gen_load_int(dig)
        elseif accept(SYM_GLOBAL) then
                i = code_ptr
                putbin(3, "\xa1..")
                code%[code_ptr - 2] = table%[var + DICT_OFS]
                if accept('(') then
                        code_ptr = i
                        while not is_lex(')')
                                expr(0)
                                putbin(1, "\x50")
                                if not accept(',') then
                                        break
                                end
                        end
                        expect(')')
                        putbin(4, "\xFF\x16..")
                        code%[code_ptr - 2] = table%[var + DICT_OFS]
                elseif accept('[') then
                        putbin(1, "\x50")
                        expr(0)
                        putbin(7, "\x5B\x01\xC3\x8A\x07\xb4\x00")
                        expect(']')
                elseif accept('%') then
                        expect('[')
                        putbin(1, "\x50")
                        expr(0)
                        putbin(5, "\x5B\x01\xC3\x8B\x07")
                        expect(']')
                end
        elseif accept(SYM_PARAM) then
                t = 2 + table%[csub + DICT_PAR] - table%[var + DICT_PAR]
                putbin(3, "\x8b\x46\.")
                code[code_ptr - 1] = shl(t, 1)
        elseif accept(SYM_LOCAL) then
                t = shl(1 + table%[var + DICT_PAR], 1)
                putbin(3, "\x8b\x46.")
                code[code_ptr - 1] = -t
        elseif accept(SYM_FN) then
                if accept('(') then
                        while not is_lex(')')
                                expr(0)
                                putbin(1, "\x50")
                                if not accept(',') then
                                        break
                                end
                        end
                        expect(')')
                        gen_call(table%[var + DICT_OFS])
                else
                        putbin(3, I86_MOV_AX)
                        code%[code_ptr - 2] = table%[var + DICT_OFS]
                end
        elseif accept(SYM_CONST) then
                i = table%[var + DICT_OFS]
                if is_neg then
                        i = -i
                        is_neg = FALSE
                end
                gen_load_int(i)
        elseif accept(SYM_INLINE) then
                if accept('(') then
                        while not is_lex(')')
                                expr(0)
                                putbin(1, "\x50")
                                if not accept(',') then
                                        break
                                end
                        end
                        expect(')')
                end
                putbin(table%[var + DICT_PAR], table + table%[var + DICT_OFS])
        else
                return
        end

        if is_neg then
                gen_neg()
        end
        if is_not then
                gen_not()
        end

        while true
                if is_lex('=') then
                        op = '='
                        p2 = 3
                elseif is_lex(LEX_NE) then
                        op = LEX_NE
                        p2 = 3
                elseif is_lex('<') then
                        op = '<'
                        p2 = 4
                elseif is_lex(LEX_LE) then
                        op = LEX_LE
                        p2 = 4
                elseif is_lex('>') then
                        op = '>'
                        p2 = 4
                elseif is_lex(LEX_GE) then
                        op = LEX_GE
                        p2 = 4
                elseif is_lex(LEX_OR) then
                        op = LEX_OR
                        p2 = 1
                elseif is_lex(LEX_AND) then
                        op = LEX_AND
                        p2 = 2
                elseif is_lex('+') then
                        op = '+'
                        p2 = 5
                elseif is_lex('-') then
                        op = '-'
                        p2 = 5
                elseif is_lex('*') then
                        op = '*'
                        p2 = 6
                elseif is_lex('/') then
                        op = '/'
                        p2 = 6
                else
                        return
                end
                if p2 <= lvl then
                        return
                end
                nextlex()
                putbin(1, "\x50")
                expr(p2)
                putbin(3, "\x89\xc3\x58")
                gen_op(op)
        end
end

function c_param_list
        dim res
        res = 0
        while not is_lex(')')
                res = res + 1
                expr(0)
                putbin(1, "\x50")
                if not accept(',') then
                        break
                end
        end
        expect(')')
        return res
end

sub statements
        dim old_wh_continue, old_wh_break, k, i, else_jmp, exit_jmp, have_else

        while true
                if debug then
                        printc('S')
                end
                if accept(LEX_EOL) then
                        continue
                end

                if (cur_lex_type = LEX_END) or (cur_lex_type = LEX_ELSEIF) or (cur_lex_type = LEX_ELSE) or (cur_lex_type = LEX_EOF) then
                        return
                end

                i = cur_lex_ptr
                if accept(LEX_IF) then
                        have_else = FALSE
                        expr(0)
                        expect(LEX_THEN)
                        expect(LEX_EOL)
                        putbin(7, "\x85\xc0\x75\x03\xe9..")
                        else_jmp = code_ptr
                        statements()
                        while accept(LEX_ELSEIF)
                                if have_else then
                                        code%[exit_jmp - 2] = code_ptr - exit_jmp
                                end
                                putbin(3, I86_JMP)
                                exit_jmp = code_ptr
                                have_else = TRUE
                                code%[else_jmp - 2] = code_ptr - else_jmp

                                expr(0)
                                putbin(7, "\x85\xc0\x75\x03\xe9..")
                                else_jmp = code_ptr
                                expect(LEX_THEN)
                                expect(LEX_EOL)
                                statements()
                        end
                        if accept(LEX_ELSE) then
                                if have_else then
                                        code%[exit_jmp - 2] = code_ptr - exit_jmp
                                end
                                putbin(3, I86_JMP)
                                exit_jmp = code_ptr
                                have_else = TRUE
                                code%[else_jmp - 2] = code_ptr - else_jmp
                                expect(LEX_EOL)
                                statements()
                        else
                                code%[else_jmp - 2] = code_ptr - else_jmp
                        end
                        if have_else then
                                code%[exit_jmp - 2] = code_ptr - exit_jmp
                        end
                        expect(LEX_END)
                elseif accept(LEX_WHILE) then
                        old_wh_continue = wh_continue
                        old_wh_break = wh_break
                        wh_continue = code_ptr
                        expr(0)
                        putbin(7, "\x85\xc0\x75\x03\xe9..")
                        wh_break = code_ptr - 3
                        expect(LEX_EOL)
                        statements()
                        expect(LEX_END)
                        putbin(3, I86_JMP)
                        code%[code_ptr - 2] = wh_continue - code_ptr
                        wh_break = wh_break + 3
                        code%[wh_break - 2] = code_ptr - wh_break
                        wh_continue = old_wh_continue
                        wh_break = old_wh_break
                elseif accept(LEX_CONTINUE) then
                        putbin(3, I86_JMP)
                        code%[code_ptr - 2] = wh_continue - code_ptr
                elseif accept(LEX_BREAK) then
                        putbin(3, I86_JMP)
                        code%[code_ptr - 2] = wh_break - code_ptr
                elseif accept(LEX_RETURN) then
                        if cur_lex_type <> LEX_EOL then
                                expr(0)
                        end
                        putbin(3, I86_JMP)
                        stk_ret%[0] = stk_ret%[0] + 2
                        stk_ret%[stk_ret%[0]] = code_ptr
                elseif accept(LEX_DIM) then
                        while true
                                def(lex, SYM_LOCAL, cdim, cdim)
                                cdim = cdim + 1
                                expect(LEX_ID)
                                if not accept(',') then
                                        break
                                end
                        end
                elseif accept(LEX_INLINE) then
                        expect('(')
                        unesc()
                        putbin(lex_size, lex)
                        expect(LEX_STR)
                        expect(')')
                elseif accept2(SYM_FN, SYM_SUB) then
                        if accept('(') then
                                c_param_list()
                        end
                        gen_call(table%[i + DICT_OFS])
                elseif accept(SYM_INLINE) then
                        if accept('(') then
                                c_param_list()
                        end
                        putbin(table%[i + DICT_PAR], table + table%[i + DICT_OFS])
                elseif accept(SYM_PARAM) then
                        k = shl(2 + table%[csub + DICT_PAR] - table%[i + DICT_PAR], 1)
                        if accept('=') then
                                expr(0)
                                putbin(3, "\x89\x46.")
                                code[code_ptr - 1] = k
                        elseif accept('(') then
                                c_param_list()
                                putbin(3, "\xFF\x56.")
                                code[code_ptr - 1] = k
                        else
                                error()
                        end
                elseif accept(SYM_LOCAL) then
                        k = -shl(1 + table%[i + DICT_PAR], 1)
                        if accept('=') then
                                expr(0)
                                putbin(3, "\x89\x46.")
                                code[code_ptr - 1] = k
                        elseif accept('(') then
                                c_param_list()
                                putbin(3, "\xFF\x56.")
                                code[code_ptr - 1] = k
                        else
                                error()
                        end
                elseif accept(SYM_GLOBAL) then
                        k = table%[i + DICT_OFS]
                        if accept('=') then
                                expr(0)
                                putbin(3, "\xA3..")
                                code%[code_ptr - 2] = k
                        elseif accept('(') then
                                c_param_list()
                                putbin(4, "\xFF\x16..")
                                code%[code_ptr - 2] = k
                        elseif accept('[') then
                                expr(0)
                                expect(']')
                                putbin(1, "\x50")
                                expect('=')
                                expr(0)
                                putbin(7, "\x5b\x03\x1E..\x88\x07")
                                code%[code_ptr - 4] = k
                        elseif accept('%') then
                                expect('[')
                                expr(0)
                                expect(']')
                                putbin(1, "\x50")
                                expect('=')
                                expr(0)
                                putbin(7, "\x5b\x03\x1E..\x89\x07")
                                code%[code_ptr - 4] = k
                        else
                                error()
                        end
                else
                        error()
                end
                if accept(LEX_EOF) then
                        break
                end
                expect(LEX_EOL)
        end
end

sub c_fix_jmp2ret
        dim stk_ret_ptr, p

        stk_ret_ptr = stk_ret%[0]

        while (stk_ret_ptr <> 0) and (stk_ret%[stk_ret_ptr] = code_ptr)
                code_ptr = code_ptr - 3
                stk_ret_ptr = stk_ret_ptr - 2
                if debug then
                        printc('R')
                end
        end
        while stk_ret_ptr <> 0
                p = stk_ret%[stk_ret_ptr]
                code%[p - 2] = code_ptr - p
                stk_ret_ptr = stk_ret_ptr - 2
                if debug then
                        printc('R')
                end
        end
        stk_ret%[stk_ret_ptr] = 0
end

sub c_sub(type)
        dim save_dict_ptr, save_table_ptr, pcount
        dim save_buf_ptr, loc_ptr, i

        stk_ret%[0] = 0
        def(lex, type, 0, code_ptr)
        csub = dict_ptr
        cdim = 0
        save_dict_ptr = dict_ptr
        save_table_ptr = table_ptr
        pcount = 0
        putbin(3, "\x55\x89\xe5")
        putbin(3, "\x83\xec.")
        loc_ptr = code_ptr
        expect(LEX_ID)
        if accept('(') then
                while TRUE
                        pcount = pcount + 1
                        def(lex, SYM_PARAM, pcount, pcount)
                        expect(LEX_ID)
                        if not accept(',') then
                                break
                        end
                end
                expect(')')
        end
        expect(LEX_EOL)
        table%[save_dict_ptr + DICT_PAR] = pcount
        statements()
        expect(LEX_END)
        expect2(LEX_EOL, LEX_EOF)
        code[loc_ptr - 1] = shl(cdim, 1)
        c_fix_jmp2ret()
        gen_ret(pcount)
        dict_ptr = save_dict_ptr
        table_ptr = save_table_ptr
end

sub c_dim
        while true
                def(lex, SYM_GLOBAL, 0, code_ptr)
                expect(LEX_ID)
                code_ptr = putw(code, code_ptr, 0)
                if not accept(',') then
                        break
                end
        end
        expect(LEX_EOL)
end

sub c_const
        dim bytes, t, val
        while true
                def(lex, SYM_CONST, 0, 0)
                expect(LEX_ID)
                expect('=')
                if accept(LEX_FILE) then
                        expect('(')
                        val = code_ptr
                        if cur_lex_type <> LEX_STR then
                                error()
                        end
                        unesc()
                        bytes = bload(lex, code + code_ptr)
                        if bytes = 0 then
                                if have_lib_dir then
                                        strcpy(FREE_MEMORY, lib_dir)
                                        bytes = len(lib_dir)
                                        basename(FREE_MEMORY + bytes, lex)
                                        bytes = bload(FREE_MEMORY, code + code_ptr)
                                        if bytes = 0 then
                                                error()
                                        end
                                else
                                        error()
                                end
                        end
                        code_ptr = code_ptr + bytes
                        expect(LEX_STR)
                        expect(')')
                elseif cur_lex_type = LEX_STR then
                        unesc()
                        val = code_ptr
                        putbin(lex_size, lex)
                        putbin(1, "\x00")
                        expect(LEX_STR)
                elseif cur_lex_type = LEX_CHAR then
                        val = lex[1]
                        expect(LEX_CHAR)
                else
                        val = digit
                        expect(LEX_DIGIT)
                end
                table%[dict_ptr + DICT_OFS] = val
                if not accept(',') then
                        break
                end
        end
        expect2(LEX_EOL, LEX_EOF)
end

sub c_declare
        dim pcount, t

        t = cur_lex_type
        if accept(LEX_SUB) then
                t = SYM_SUB
        elseif accept(LEX_FUNCTION) then
                t = SYM_FN
        else
                expect(LEX_SUB)
        end
        def(lex, t, 0, 0)
        expect(LEX_ID)
        pcount = 0
        if accept('(') then
                while not eol
                        pcount = pcount + 1
                        nextlex()
                        if not accept(',') then
                                break
                        end
                end
                expect(')')
        end
        table%[dict_ptr + DICT_PAR] = pcount
        if accept(LEX_AT) then
                t = cur_lex_ptr
                expect(SYM_CONST)
                expect('[')
                table%[dict_ptr + DICT_OFS] = table%[t + DICT_OFS] + digit
                expect(LEX_DIGIT)
                expect(']')
        elseif accept(LEX_INLINE) then
                expect('(')
                if cur_lex_type <> LEX_STR then
                        error()
                end
                unesc()
                if lex_size > 255 then
                        error()
                end
                table%[dict_ptr + DICT_TYP] = SYM_INLINE
                table%[dict_ptr + DICT_PAR] = lex_size
                table%[dict_ptr + DICT_OFS] = table_ptr
                t = 0
                while t < lex_size
                        table[table_ptr] = lex[t]
                        table_ptr = table_ptr + 1
                        t = t + 1
                end
                expect(LEX_STR)
                expect(')')
        else
                error()
        end
        expect2(LEX_EOL, LEX_EOF)
end

# Compile Initialization/finalization
sub c_initial_final(t)
        dim loc_ptr
        dim save_dict_ptr, save_table_ptr

        stk_ret%[0] = 0
        def("", t, 0, code_ptr)
        expect(LEX_EOL)

        save_dict_ptr = dict_ptr
        save_table_ptr = table_ptr

        putbin(3, "\x55\x89\xe5")
        putbin(3, "\x83\xec.")
        loc_ptr = code_ptr
        cdim = 0
        statements()
        expect(LEX_END)
        expect2(LEX_EOL, LEX_EOF)
        code[loc_ptr - 1] = shl(cdim + 1, 1)
        c_fix_jmp2ret()
        gen_ret(0)

        dict_ptr = save_dict_ptr
        table_ptr = save_table_ptr
end

function compile(fname)
        dim save_f, save_buf_ptr, save_lnum
        dim total_lines

        total_lines = 0
        save_f = f
        save_buf_ptr = buf_ptr
        save_lnum = lnum
        f = fopenr(fname)
        if f = 0 then
                if have_lib_dir then
                        strcpy(FREE_MEMORY, lib_dir)
                        save_lnum = len(lib_dir)
                        basename(FREE_MEMORY + save_lnum, fname)
                        f = fopenr(FREE_MEMORY)
                        if f = 0 then
                                error()
                        end
                else
                        error()
                end
        end
        print(fname)
        println()
        buf_ptr  = buf_size + 1
        buf = buf + 128
        eof = FALSE
        eol = FALSE
        lnum = 0

        nextline()
        nextlex()
        while not accept(LEX_EOF)
                if debug then
                        printc('C')
                end
                if accept(LEX_EOL) then
                        continue
                end
                if accept(LEX_SUB) then
                        c_sub(SYM_SUB)
                elseif accept(LEX_FUNCTION) then
                        c_sub(SYM_FN)
                elseif accept(LEX_DIM) then
                        c_dim()
                elseif accept(LEX_DECLARE) then
                        c_declare()
                elseif accept(LEX_CONST) then
                        c_const()
                elseif accept(LEX_INIT) then
                        c_initial_final(SYM_INIT)
                elseif accept(LEX_FINAL) then
                        c_initial_final(SYM_DONE)
                elseif accept('$') then
                        if accept(LEX_INCLUDE) then
                                if cur_lex_type <> LEX_STR then
                                        error()
                                end
                                unesc()
                                total_lines = total_lines + compile(lex)
                                nextline()
                                nextlex()
                        else
                                error()
                        end
                else
                        error()
                end
        end

        fclose(f)
        total_lines = total_lines + lnum
        buf = buf - 128
        f = save_f
        buf_ptr = save_buf_ptr
        lnum = save_lnum
        eof = FALSE
        cur_lex_type = 0
        return total_lines
end

initialization
        debug = false

        lib_dir = FREE_MEMORY
        FREE_MEMORY = FREE_MEMORY + 256

        out_file = FREE_MEMORY
        FREE_MEMORY = FREE_MEMORY + 256

        map_file = FREE_MEMORY
        FREE_MEMORY = FREE_MEMORY + 256

        stk_ret = FREE_MEMORY
        FREE_MEMORY = FREE_MEMORY + 256

        lex = FREE_MEMORY
        FREE_MEMORY = FREE_MEMORY + 1024
        line = FREE_MEMORY
        FREE_MEMORY = FREE_MEMORY + 1024
        buf = FREE_MEMORY
        FREE_MEMORY = FREE_MEMORY + 2048
        table = FREE_MEMORY
        FREE_MEMORY = FREE_MEMORY + 6144
        code = FREE_MEMORY

        code_ptr = 256
        code_ofs = 256
        lex_size = 0
        buf_size = 128
        table_ptr = 0
        dict_ptr = -1
        code_ofs = 256
end

initialization
        def("INCLUDE", LEX_INCLUDE, 0, 0)
        def("SUB", LEX_SUB, 0, 0)
        def("FUNCTION", LEX_FUNCTION, 0, 0)
        def("DIM", LEX_DIM, 0, 0)
        def("INITIALIZATION", LEX_INIT, 0, 0)
        def("FINALIZATION", LEX_FINAL, 0, 0)
        def("END", LEX_END, 0, 0)
        def("IF", LEX_IF, 0, 0)
        def("THEN", LEX_THEN, 0, 0)
        def("ELSEIF", LEX_ELSEIF, 0, 0)
        def("ELSE", LEX_ELSE, 0, 0)
        def("WHILE", LEX_WHILE, 0, 0)
        def("BREAK", LEX_BREAK, 0, 0)
        def("CONTINUE", LEX_CONTINUE, 0, 0)
        def("RETURN", LEX_RETURN, 0, 0)
        def("AT", LEX_AT, 0, 0)
        def("INLINE", LEX_INLINE, 0, 0)
        def("TRUE", LEX_TRUE, 0, 0)
        def("FALSE", LEX_FALSE, 0, 0)
        def("NOT", LEX_NOT, 0, 0)
        def("OR", LEX_OR, 0, 0)
        def("AND", LEX_AND, 0, 0)
        def("FILE", LEX_FILE, 0, 0)
        def("DECLARE", LEX_DECLARE, 0, 0)
        def("CONST", LEX_CONST, 0, 0)
        def("INT_SIZE", SYM_CONST, 0, gen_word_size())
end

initialization
        print(get_name())

        if paramcount() <> 1 then
                print("\nUsage:\n\tPL2C source.pl2\n")
                halt(1)
        end

        getenv("PL2_HOME", lib_dir)
        if len(lib_dir) = 0 then
                print("WARN:Env var PL2_HOME is not set.\n")
        else
                have_lib_dir = true
                dim n
                n = len(lib_dir)
                if (lib_dir[n] <> '\\') and (lib_dir[n] <> '/') then
                        lib_dir[n] = '\\'
                        n = n + 1
                        lib_dir[n] = 0
                end
                strcpy(lib_dir + n, "LIB\\")
        end
end

finalization
        if rcode <> 0 then
                return
        end

        print("Save ")
        print(out_file)
        printc(' ')
        printi(out_lines)
        print(" lines, ")
        printi(code_ptr - code_ofs)
        print(" bytes\n")

        bsave(out_file, code + code_ofs, code_ptr - code_ofs)

        table_ptr = putw(table, table_ptr, dict_ptr)
        bsave(map_file, table, table_ptr)
end

sub main
        dim in_file

        in_file = paramstr(1)
        change_ext(out_file, in_file, ".com")
        change_ext(map_file, in_file, ".map")
        pg_start()
        out_lines = compile(in_file)
        pg_end()
        halt(0)
end
